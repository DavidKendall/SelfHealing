\documentclass{ieeeaccess}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
%\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{relsize}
\usepackage{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{array}
%\usepackage{caption}
%\usepackage[caption=false,font=footnotesize]{subfig}
%\usepackage{fixltx2e}
\usepackage{float}
\usepackage{url}
%\usepackage{becs}
\usepackage{listings}
\lstset{%
  basicstyle=\normalsize,
  numbers=left,
  numberstyle=\normalsize,
  stepnumber=1,
  xleftmargin=2em
}
\usepackage{color}
\usepackage{tabularx}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\let\latexvec=\vec
\let\vec=\latexvec
\interdisplaylinepenalty=2500
\newtheorem{definition}{Definition}
\newtheorem{exampleb}{Example}
\newcommand{\subsubsubsection}[1]{\medskip\par\textit{#1:}}
\newcommand{\card}[1]{\vert{#1}\vert}
\newcommand{\magn}[1]{\Vert{#1}\Vert}
\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}
\renewcommand{\caption}[1]{}
\history{Date of publication xxxx 00, 0000, date of current version xxxx 00, 0000.}
\doi{10.1109/ACCESS.2017.DOI}
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{Concave reduction in Self-Healing Swarms}
\author{\uppercase{Neil Eliot}\authorrefmark{1},
\uppercase{David Kendall\authorrefmark{1}, Michael Brockway\authorrefmark{1}, Alun Moon\authorrefmark{1}}}
\address[1]{Northumbria University, Department of Computing and Information Sciences, Newcastle upon Tyne, NE1 8ST}

\begin{enumerate}
	\item Let the swarm be the set of agents $a\in\mathcal{S}$

	\item For an agent $b\in\mathcal{S}$ the set of neighbours is $\mathcal{N}_b$.
		The number of neighbours is $\#\mathcal{N}_b$
	
	\item Each neighbour has a tuple $(I,\beta,r)$ where $I$ is the identity of the agent,
		$\beta$ is the `\emph{bearing}', and $r$ the distance to the neighbour.
	
	\item We can list the tuples in s sequence 
		\[ \mathcal{Q}_b = \langle \ldots (I_n,\beta_n,r_n) \ldots \rangle \]
		such that $\beta_n<\beta_{n+1}$ these are the encircling neighbours.
	
	\item We can write a corresponding sequecnce of perimeter edges
		\[ \mathcal{P}_b = \langle \ldots (\theta_n,d_n) \ldots \rangle \]
		$\theta$ is the angle subtended at $b$ by the edge and $d$ is the length of the edge
		\[ \theta_i = (\beta_{(i+1)\mathrm{mod} \#\mathcal{N}_b} - \beta_i)\mathrm{mod}2\pi \]
		The $\mathrm{mod}\#\mathcal{N}_b$ wraps the sequence round connecting the ends.
		The $\mathrm{mod}2\pi$ ensures that $\forall i : \theta_i>0$, 
		and that $\sum\theta_i = 2\pi$

		From the cosine rule
		\[ d_i^2 = r_i^2 + r_{(i+1)\mathrm{mod}\#\mathcal{N}_b}^2 - 2 r_i 
			r_{(i+1)\mathrm{mod}\#\mathcal{N}_b} \cos \theta_i
		\]

	\item An agent is on the perimeter if
		\[
			\exists d_n \in \mathcal{P}_b : d_n>d_v
		\]
		where $d_v$ is the range over which agents are `\emph{visible}' to each other.
	
	\item An agent is on the perimeter $p$ if
		\[
			\exists \theta_n \in \mathcal{P}_b : \theta_n\geq\pi
		\]
		This includes the cases where the edges form a straight section of the perimeter

	\item An agent is at the apex of a concave section of perimeter $v$ if
		\[ 
			\exists (\theta_i,d_i) \in \mathcal{P}_b : d_n>d_v \vee \theta_i<\pi
		\]
\end{enumerate}

\paragraph{Some properties:}
\begin{tabularx}{\columnwidth}{cccX}
	$\#\mathcal{N}_b$ & $p$ & $c$ & condition \\
	1 & T & F & $\theta_1=2\pi\geq\pi$ \\
	2 & T & F & $\theta_1+\theta_2=2\pi \therefore \theta_n\geq\pi$ \\
	3 & T & T & if $\theta_n=2\pi/3$ then $d_n>d_v$ \\
	3 & T & F & if $\forall d_n: d_n<d_v$ then $\exists\theta_i:\theta_i>\pi$
\end{tabularx}

\paragraph{Orientation independent}  If the agent $b$ is rotated through an angle of $\gamma$ then 
the bearings are rotated by $-\gamma$, \[ \beta_i\mapsto\beta_i-\gamma \]
The subtended angle is now
\[
	\theta_i  =  ( (\beta_{(i+1)\mathrm{mod}\#\mathcal{N}_b}-\gamma) - (\beta_i-\gamma))\mathrm{mod}2\pi 
\]
\[
	\theta_i = (\beta_{(i+1)\mathrm{mod}\#\mathcal{N}_b}-\beta_i-\gamma+\gamma)\mathrm{mod}2\pi
\]
\[
	\theta_i = (\beta_{(i+1)\mathrm{mod}\#\mathcal{N}_b}-\beta_i )\mathrm{mod}2\pi
\]
\clearpage
\begin{figure}
\begin{algorithmic}[1]
%\tiny
\Procedure{SmallNeighbourCount}{$b$}
\If{$|nbr(b)| \leq 4$}
   \State\textbf{return} $True$
\EndIf
\State\textbf{return} $False$
\EndProcedure
\end{algorithmic}
\caption{Small Neighbour Count}
\label{algo:SmallNeighbourCount}
What is \textit{nbr}
\end{figure}

\begin{figure}
\begin{algorithmic}[1]
%\tiny
\Procedure{NeighbourAngle}{$b$}
\State $angles \gets \emptyset$
\For{$b^{'}\in b.neighbours$}
\If{$b.neighbours[0] = b^{'}$}
  \State $angles[b^{'}] \gets 0$
\Else
   \State $angles[b^{'}] \gets $ \hfill
  \Statex \hfill $b.getAngle(b.neighbours[0], b^{'})$ 
\EndIf
\EndFor
\State\textbf{return} $sort(angles)$ 
\EndProcedure
\end{algorithmic}
\caption{NeighbourAngle: Sorted by angle}
\label{algo:getNeighbourAngles}

\end{figure}

\begin{figure}
\begin{algorithmic}[1]
%\tiny
\Procedure{CheckVisibility}{$b,angles$}
\For{$i \gets 0~\texttt{To}~size(angles)-1$}
\If{i = size(angles)-1}
\If{$cosrule(b,angles[size(angles)-1][0],angles[i][0])$}
\State\textbf{return} $True$
   \EndIf
\ElsIf{$cosrule(b,angles[i + 1][0],angles[i][0])$}
\State\textbf{return} $True$
\EndIf
\EndFor
\State\textbf{return} $False$
\EndProcedure
\end{algorithmic}
\caption{Check Visibility}
\label{algo:CheckVisibility}
\end{figure}

\begin{figure}
\begin{algorithmic}[1]
%\tiny
\Procedure{CheckConvex}{$angles$}
\For{$i \gets 0~\texttt{To}~size(angles)-1$}
\If{i = size(angles)-1}
\If{$360 - angles[loop][1] \geq 180$}
\State\textbf{return} $True$
\EndIf
\EndIf
\If{$angles[loop + 1][1] - angles[loop][1] \geq 180$}
\State\textbf{return} $True$
\EndIf
\EndFor
\State\textbf{return} $False$
\EndProcedure
\end{algorithmic}
\caption{Check Convex}
\label{algo:CheckConvex}
\end{figure}

\begin{figure}
\begin{algorithmic}[1]
%\tiny
\Procedure{CheckPerimeter}{$b,S$}
\If{SmallNeighbourCount(b,S)}
\State\textbf{return} $True$
\EndIf
\State$angles = NeighbourAngle(b)$
\If{CheckVisibility(b,angles)}
\If{CheckConvex(angles)}
\State\textbf{return} $True$
\EndIf
\EndIf
\State\textbf{return} $False$
\EndProcedure
\end{algorithmic}
\caption{Check Perimeter}
\label{algo:CheckPerimeter}
\end{figure}

\begin{figure}
\begin{algorithmic}[1]
\Procedure{CheckVisibility}{$b,angles$}
\State $b.gap \gets \emptyset$
\State $b.concave = False$
\For{$i \gets 0~\texttt{To}~size(angles)-1$}
\If{i = size(angles)-1}
\If
{$cosrule(b,angles[size(angles)-1][0], angles[i][0])$}
\If{$angle(b,angles[size(angles)-1][0], angles[i][0]) < 180)$}
\State $b.concave = True$
\State $b.gap = (angles[size(angles)-1][1], angles[i][1])$
\EndIf
   \State\textbf{return} $True$
   \EndIf
\EndIf
\If{$cosrule(b,angles[i + 1][0],angles[i][0])$}
  \If{$angle(b,angles[i + 1][0],angles[i][0]) < 180$}
\State $b.concave = True$\;
\State $b.gap = (angles[i + 1][1],angles[i][1])$
  \EndIf
  \State\textbf{return} $True$
\EndIf
\EndFor
\State\textbf{return} $False$
\EndProcedure
\end{algorithmic}
\caption{Check Visibility}
\label{algo:checkVisibility2}
\end{figure}

\EOD

\end{document}
